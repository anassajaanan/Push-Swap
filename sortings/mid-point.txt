void    stack_to_array(int *array, t_stack *stack, int length)
{
    int i;
    struct s_stack_node *p;

    i = 0;
    p = stack->top;
    while (i < length)
    {
        array[i] = p->val;
        p = p->next;
        i++;
    }
}

int get_pivot(t_stack *stack, int length)
{
    int *array = (int *)malloc(sizeof(int) * length);
    stack_to_array(array, stack, length);
    bubble_sort(array, length);
    int pivot = array[length / 2];
    free(array);
    return (pivot);
}

void    mid_point(t_stack *a, t_stack *b, int len)
{
    if (len == 1)
        return;
    else if (len == 2)
    {
        if (a->top->val > a->top->next->val)
            ft_sa(a);
        return;
    }
    else if (len > 2)
    {
        int rotate_count_a = 0;
        int pivot = get_pivot(a, len);
        int chunk_size = len / 2;
        int i = 0;
        while (i < chunk_size)
        {
            if (a->top->val < pivot)
            {
                ft_pb(a, b);
                i++;
            }
            else if (a->last->val < pivot)
            {
                ft_rra(a);
                ft_pb(a, b);
                i++;
            }
            else
            {
                ft_ra(a);
                rotate_count_a++;
            }
        }
        while (rotate_count_a > 0)
        {
            ft_rra(a);
            rotate_count_a--;
        }
        mid_point(a, b, len - chunk_size);

        while (chunk_size > 0)
        {
            if (chunk_size == 1)
            {
                ft_pa(a, b);
                break;
            }
            else if (chunk_size == 2)
            {
                if (b->top->val < b->top->next->val)
                    ft_sb(b);
                ft_pa(a, b);
                ft_pa(a, b);
                break;
            }
            else
            {
                int pivot_b = get_pivot(b, chunk_size);
                int rotate_count = 0;
                int j = 0;
                while (j < (chunk_size - (chunk_size / 2 + 1)))
                {
                    if (b->top->val > pivot_b)
                    {
                        ft_pa(a, b);
                        j++;
                    }
                    else
                    {
                        ft_rb(b);
                        rotate_count++;
                    }
                }
                while (rotate_count > 0)
                {
                    ft_rrb(b);
                    rotate_count--;
                }
                mid_point(a, b, chunk_size - (chunk_size / 2 + 1));
                chunk_size = chunk_size / 2 + 1;
            }
        }
    }
}