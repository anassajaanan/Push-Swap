void	swap(int *a, int *b)
{
	int temp;

	temp = *a;
	*a = *b;
	*b = temp;
}

void	bubble_sort(int A[], int size)
{
	int	i;
	int	j;
	int	flag;

	i = 0;
	while (i < size - 1)
	{
		j = 0;
		flag = 0;
		while (j < size - 1 - i)
		{
			if (A[j] > A[j + 1])
			{
				swap(&A[j], &A[j + 1]);
				flag = 1;
			}
			j++;
		}
		if (flag == 0)
			return ;
		i++;
	}
}

void    stack_to_array(int *array, t_stack *stack, int length)
{
	int i;
	struct s_stack_node *p;

	i = 0;
	p = stack->top;
	while (i < length)
	{
		array[i] = p->val;
		p = p->next;
		i++;
	}
}

int get_pivot(t_stack *stack, int length)
{
	int *array = (int *)malloc(sizeof(int) * length);
	stack_to_array(array, stack, length);
	bubble_sort(array, length);
	int pivot = array[length / 2];
	free(array);
	return (pivot);
}


void    sort_b(t_stack *a, t_stack *b, int len_b);

void    sort_a(t_stack *a, t_stack *b, int len)
{
	if (is_a_sorted(a))
		return;
	if (len == 1)
		return ;
	else if (len == 2)
	{
		if (a->top->val > a->top->next->val)
			ft_sa(a);
		return ;
	}
	else if (len == 3 && a->length == 3)
	{
		int max = get_max(*a);
		if (a->top->val == max)
			ft_ra(a);
		else if (a->top->next->val == max)
			ft_rra(a);
		if (a->top->val > a->top->next->val)
			ft_sa(a);
		return ;
	}
	else
	{
		int pivot = get_pivot(a, len);
		int i = 0;
		int rot = 0;
		while (i < len / 2)
		{
			if (a->top->val < pivot)
			{
				ft_pb(a, b);
				i++;
			}
			else if (a->last->val < pivot)
			{
				ft_rra(a);
				ft_pb(a, b);
				i++;
			}
			else
			{
				ft_ra(a);
				rot++;
			}
		}
		while (rot > 0)
		{
			ft_rra(a);
			rot--;
		}
		sort_a(a, b, len - len / 2);
		sort_b(a, b, len / 2);
	}
}



void    sort_b(t_stack *a, t_stack *b, int len_b)
{
	if (is_b_sorted(b))
	{
		while (b->top)
			ft_pa(a, b);
		return ;
	}
	if (len_b <= 1)
	{
		ft_pa(a, b);
		return;
	}
	else if (len_b == 2)
	{
		if (b->top->val < b->top->next->val)
			ft_sb(b);
		ft_pa(a, b);
		ft_pa(a, b);
	}
	else if (len_b == 3 && b->length == 3)
	{
		int min = get_min(*b);
		if (b->top->val == min)
			ft_sb(b);
		else if (b->top->next->val == min)
			ft_rrb(b);
		if (b->top->val < b->top->next->val)
			ft_sb(b);
		return ;
	}
	else if (len_b > 3 && len_b < 15)
	{
		int j = 0;
		while (j < len_b)
		{
			bring_max_top(b);
			ft_pa(a, b);
			j++;
		}
		return ;
	}
	else
	{
		int pivot = get_pivot(b, len_b);
		int i = 0;
		int rot = 0;
		while (i < len_b - len_b / 2)
		{
			if (b->top->val >= pivot)
			{
				ft_pa(a, b);
				i++;
			}
			else if (b->last->val >= pivot)
			{
				ft_rrb(b);
				ft_pa(a, b);
				i++;
			}
			else
			{
				ft_rb(b);
				rot++;
			}
		}
		while (rot > 0)
		{
			ft_rrb(b);
			rot--;
		}
		sort_a(a, b, len_b - len_b / 2);
		sort_b(a, b, len_b / 2);
	}
}